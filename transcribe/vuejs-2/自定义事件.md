
# 自定义事件

## 事件名

不同于组件和prop，事件名不存在任何自动化的大小写转换。而是触发的事件完全匹配监听这个事件所用的名称。举个例子，如果触发一个 camelCase 名字的事件：

```js
this.$emit('myEvent')
```

则监听这个名字的 kebab-case 版本是不会有任何效果的：

```html
<!-- 没有效果 -->
<my-component v-on:my-event="doSomething"></my-component>
```

不同于组件和prop，事件名不会被用作一个Javascript变量名或property名，所以就没有理由使用 camelCase 或PascalCase 了。并且 `v-on` 事件监听器在DOM模板中会被自动转换为全小写，因为HTML是大小写不敏感的，所以 `v-on:myEvent` 将会变成 `v-on:myevent`, 导致 `myEvent` 不可能被监听到。

因此，我们推荐你始终使用 kabab-case 事件名。


## 自定义组件的 v-model

一个组件上的 `v-model` 默认会利用名为 `value` 的prop和名为 `input` 的事件，但是像单选框、复选框等类型的输入控件可能会将 `value` attribute 用于不同的目的。`model` 选项可以用来避免这样的冲突：

```js
Vue.component('base-checkbox', {
  model: {
    prop: 'checked',
    event: 'change'
  }, 
  props: {
    checked: Boolean
  },
  template: `
    <input
      type="checkbox"
      :checked="checked"
      @change="$emit('change', $event.target.checked)"
    >
  `
})
```

现在在这个组件上使用 `v-model` 的时候：

```html
<base-checkbox v-model="lovingVue"></base-checkbox>
```

这里的 `lovingVue` 的值将会传入这个名为 `checked` 的prop。同时当 `<base-checkbox>` 触发一个 `change` 事件并附带一个新的值的时候，这个 `lovingVue` 的property 将会被更新。

> 注意你仍然需要在组件的 `props` 选项里声明 `checked` 这个 prop。


## 将原生事件绑定到组件

你可能有很多次想要在一个组件的根元素上直接监听一个原生事件。这时，你可以使用 `v-on` 的 `.native` 修饰符：

```html
<base-input v-on:focus.native="onFocus"></base-input>
```

