# 处理边界情况


> 这里记录的都是和处理边界情况有关的功能，即一些需要对 Vue 的规则做一些小调整的特殊情况。不过注意这些功能都是有劣势或者危险的场景的。我们会在每个案例中注明，所以当你使用每个功能的时候稍加留意。


## 访问元素&组件

在绝大多数情况下，我们最好不要触达另一个组件实例内部或手动操作DOM元素。不过也确实在一些情况下做这些事情是合适的。

#### 访问根实例

在每个 `new Vue` 实例的子组件中，其根实例可以通过 `$root` property 进行访问。例如，在这个根实例中：

```js
new Vue({
  data: {
    foo: 1
  },
  computed: {
    bar: function() {

    },
  },
  methods: {
    baz: function() {}
  }
})
```

所有的子组件都可以将这个实例作为一个全局store来访问或使用。

```js
//获取根组件的数据
this.$root.foo 

// 写入根组件的数据
this.$root.foo = 2

// 访问根组件的计算属性
this.$root.bar

// 调用根组件的方法
this.$root.baz()
```

> 对于demo或非常小型的有少量组件的应用来说这是很方便的。不过这个模式扩展到中大型应用来说就不然了。因此在绝大多数情况下，我们强烈推荐使用 `Vuex` 来管理应用的状态。

#### 访问父级组件实例

和 `$root` 类似，`$parent` property可以用来从一个子组件访问父组件的实例。它提供了一种机会，可以在后期随时触达父组件，以替代将数据以prop的方式传入子组件的方式。

> 在绝大多数情况下，触达父级组件会使得你的应用更加难调试和理解，尤其是当你变更了父组件的数据的时候，当我们稍后会看那个组件的时候，很难找出那个变更是从哪里发起的。

另外在一些可能适当的时候，你需要特别地共享一些组件库。举个例子，在和JavaScript API进行交互而不渲染HTML的抽象组件内，诸如这些假设性的Google地图组件一样：

```html
<google-map>
  <google-map-markers v-bind:places="iceCreamShops"></google-map-markers>
</google-map>
```

这个 `<google-map>`组件可以定义一个 `map` property ，所有的子组件都需要访问它。在这种情况下 `<google-map-markers>` 可能想要通过类似 `this.$parent.getMap` 的方式访问那个地图，以便为其添加一组标记。

请留意，尽管如此，通过这种模式构建出来的那个组件的内部仍然是容易出问题的。比如，设想一下我们添加一个新的 `<google-map-region>` 组件，当`<google-map-markers>`在其内部出现的时候，只会渲染那个区域内的标记：

```html
<google-map>
  <google-map-region v-bind:shape="cityBoundaries">
    <google-map-markers v-bind:places="iceCreamShops"></google-map-markers>
  </google-map-region>
</google-map>
```

那么在`<google-map-markers>`内部你可能发现自己需要一些类似这样的 hack：

```js
var map = this.$parent.map || this.$parent.$parent.map
```

很快它就会失控，这也是我们针对需求向任意更深层级的组件提供上下文信息时推荐 **依赖注入** 的原因。

#### 访问子组件实例或子元素

尽管存在prop和事件，有的时候你仍可能需要在Javascript里直接访问一个子组件。为了达到这个目的，你可以通过 `ref` 这个attribute为子组件赋予一个ID引用。例如：

```html
<base-input ref="usernameInput"></base-input>
```

现在在你已经定义了这个 `ref` 的组件里，你可以使用：

```js
this.$refs.usernameInput
```

来访问这个 `<base-input>` 实例，以便不时之需。比如程序化地从一个父级组件聚焦这个输入框。在刚才例子中，该 `<base-input>` 组件也可以使用一个类似的 `ref` 提供对内部这个指定元素的访问，例如：

```html
<input ref="input">
```

甚至可以通过其父级组件定义方法：

```js
methods: {
  // 用来从父级组件聚焦输入框
  focus: function () {
    this.$refs.input.focus()
  }
}
```

这样就允许父级组件通过下面的代码聚焦`<base-input>`里的输入框：

```js
this.$refs.usernameInput.focus()
```

当 `ref` 和 `v-for` 一起使用的时候，你得到的ref将会是一个包含了对应数据源的这些子组件的数组。

> `$refs` 只会在组件渲染完成之后生效，并且它们不是响应式的。这仅作为一个用于直接操作子组件的“逃生舱”————你应该避免在模板或计算属性中访问 `$refs`。

#### 依赖注入

在此前，在我们描述访问父级组件实例的时候，展示过一个类似这样的例子：

```html
<google-map>
  <google-map-region v-bind:shape="cityBoundaries">
    <google-map-markers v-bind:places="iceCreamShops"></google-map-markers>
  </google-map-region>
</google-map>
```

在这个组件里，所有`<google-map>`的后代都需要访问一个 `getMap` 方法，以便知道要跟哪个地图进行交互。不幸的是，使用`$parent`property 无法很好的扩展到更深层级的嵌套组件上。这也是依赖注入的用武之地，他用到了两个新的实例选项： `provide` 和 `inject`。

`provide` 选项允许我们指定我们想要提供给后代组件的数据/方法。在这个例子中，就是 `<google-map>`内部的 `getMap` 方法：

```js
provide: function() {
  return {
    getMap: this.getMap
  }
}
```

然后在任何后代组件里，我们都可以使用 `inject` 选项来接收指定的我们想要添加在这个实例上的property:

```js
inject: ['getMap']
```

然后在任何后代组件里，我们都可以使用 `inject` 选项来接收指定的我们想要添加在这个实例上的property：

```js
inject: ['getMap']
```

相比 `$parent` 来说，这个用法可以让我们在任意后代组件中访问 `getMap` ，而不需要暴露整个 `<google-map>` 实例。这允许我们更好的持续研发该组件，而不需要担心我们可能改变/移除一些组件依赖的东西。同时这些组件之间的接口是始终明确定义的，就像`props`一样。

实际上，你可以把依赖注入看作一部分“大范围有效的prop“，除了：
- 祖先组件不需要知道哪些后代组件使用它提供的property
- 后代组件不需要知道被注入的property来自哪里的

> 然而，依赖注入还是有负面影响的。它将你应用程序中的组件与它们当前的组织方式耦合起来，使重构变得更加困难。同时所提供的property是非响应式的。这是出于设计的考虑，因为使用它们来创建一个中心化规模化的数据跟使用 `$root` 做这件事都是不够好的。如果你想要共享的这个property是你的应用特有的，而不是通用化的，或者如果你想在祖先组件中更新所提供的数据，那么这意味着你可能需要换用一个像Vuex这样真正的状态管理方案了。

